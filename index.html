<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AWS SAA Learning: Practice Q&A</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --aws-blue: #232f3e;
      --aws-orange: #ff9900;
    }

    /* Set default font and background */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6;
      color: #1f2937;
    }

    .wrap {
      max-width: 960px;
      margin: 0 auto;
      padding: 0px;
      font-size: 0.875rem;
    }

    .screen {
      display: none;
    }

    .show-flex {
      display: flex;
      flex-direction: column;
    }

    /* Custom styles for option feedback */
    .option-label {
      display: flex;
      align-items: flex-start;
      margin: 2px 0;
      padding: 5px;
      cursor: pointer;
      transition: all 0.15s ease-in-out;
      border: 1px solid #e5e7eb;
      font-size: 0.875rem;
    }

    .option-label:hover:not(.correct-answer):not(.incorrect-selection) {
      background-color: #f9fafb;
    }

    .correct-answer {
      /* Keep green for correct answers */
      background-color: #ecfdf5;
      border-color: #34d399;
      font-weight: 600;
      color: #059669;
    }

    .incorrect-selection {
      /* Removed red coloring as requested */
      background-color: transparent;
      border-color: #d1d5db;
      /* Neutral border */
      color: #1f2937;
      /* Neutral text */
    }

    .option-label input[type="checkbox"] {
      margin-top: 2px;
      min-width: 0.8rem;
      min-height: 0.8rem;
    }

    .option-label span {
      margin-left: 10px;
    }

    /* Style for the Explanation box - Removed background/border color */
    #explanation {
      display: none;
      margin-top: 20px;
      padding: 2px;
      background-color: transparent;
      /* No background color */
      border-left: 5px solid #d1d5db;
      /* Neutral gray border */
      color: #1f2937;
      /* Dark text color */
      line-height: 1.5;
      font-size: 0.875rem;
    }

    #explanation h4 {
      font-weight: 700;
      margin-bottom: 6px;
      color: #1f2937;
      /* Dark text color */
    }
  </style>
</head>

<body>
  <!-- Main Content Wrapper -->
  <div class="wrap">
    <!-- Header -->
    <header class="flex justify-between items-center p-3 border-b border-gray-300">
      <h1 class="text-xl font-extrabold text-aws-blue">
        AWS SAA Study Kit
      </h1>
      <div class="flex items-center space-x-3">
        <!-- Timer Display -->
        <div id="timerDisplay" class="text-lg font-bold text-red-600 hidden">
          00:00:00
        </div>
        <!-- Menu Button -->
        <button id="btnMenu"
          class="bg-green-500 hover:bg-green-600 text-white text-sm font-semibold py-1.5 px-3 shadow-md transition duration-200">
          HOME
        </button>
      </div>
    </header>

    <!-- Home Screen -->
    <div id="home" class="screen show-flex p-4 bg-white shadow-lg">
      <h2 class="text-lg font-semibold mb-3 text-gray-800">Welcome to the AWS SAA Practice</h2>
      <p class="mb-5 text-gray-600 text-sm">Select a mode to begin your journey to certification.</p>
      <div class="space-y-3">
        <button id="btnLearn"
          class="w-full bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2.5 px-3 transition duration-200 shadow-lg text-sm">
          Learning Mode (Step-by-Step with Explanation - 5 Questions)
        </button>
        <button id="btnPractice"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-3 shadow-lg transition duration-200 text-sm">
          Practice Exam (130 Random Questions - 150 Minutes)
        </button>
      </div>
    </div>

    <!-- Learning/Practice Screen -->
    <div id="learn" class="screen">
      <!-- Practice Mode Result View -->
      <div id="resultView" class="hidden bg-white p-5 shadow-lg mb-5">
        <h2 class="text-xl font-bold mb-3 text-gray-800">Practice Exam Results</h2>
        <div id="scoreDisplay" class="text-3xl font-extrabold text-center py-6"></div>
        <button id="btnReview"
          class="mt-3 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2.5 px-3 shadow-md transition duration-200 text-sm">
          Review Answers
        </button>
      </div>

      <!-- Question View -->
      <div id="questionView">
        <div id="qnum" class="text-base font-medium text-gray-600 mx-3"></div>
        <div class="bg-white p-2 shadow-lg">
          <div id="qtext" class="question-box font-semibold mb-5 text-gray-800"></div>
          <div id="options" class="space-y-2">
            <!-- Options will be rendered here -->
          </div>

          <!-- Explanation Area -->
          <div id="explanation">
            <h4>Explanation:</h4>
            <p id="noteText"></p>
          </div>

          <!-- Navigation for Review Mode -->
          <div id="reviewNavigation" class="mt-5 flex justify-between space-x-3 hidden">
            <!-- Buttons will be injected here during review mode -->
          </div>

          <div id="mainActions" class="mt-5 flex space-x-3">
            <button id="actionBtn"
              class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2.5 px-3 shadow-md transition duration-200 text-sm">
              CHECK
            </button>
            <button id="resetBtn"
              class="w-auto bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2.5 px-3 shadow-md transition duration-200 text-sm">RESET</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom Message/Confirmation Modal -->
  <div id="messageModal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center p-4 z-50">
    <div class="bg-white p-5 shadow-2xl w-full max-w-sm">
      <h3 id="modalTitle" class="text-lg font-bold mb-3 text-gray-800"></h3>
      <p id="modalMessage" class="text-gray-600 mb-5 text-sm"></p>
      <div id="modalActions" class="flex justify-end space-x-2">
        <!-- Buttons go here -->
      </div>
    </div>
  </div>

  <script>
    // --- LOCAL STORAGE KEYS ---
    const LS_KEY_LEARN_INDEX = "aws_learn_current_index";
    const LS_KEY_PRACTICE_ANSWERS = "aws_practice_answers";
    const LS_KEY_PRACTICE_TIME = "aws_practice_time";

    var masterData = [];
    var data = []; // Initialize with master data for learning mode access
    const NUMBER_OF_PRACTICE_QUESTIONS = 130;

    // --- GLOBAL STATE ---
    const appState = {
      mode: 'learn', // 'learn', 'practice', or 'review'
      current: 0, // Current question index being displayed (index into the 'data' array)
      practiceAnswers: [], // Stores { qIndex: 0, selections: [0, 2] }
      isReviewing: false,
      // Timer state
      timerInterval: null,
      timeRemaining: 9000, // 150 minutes * 60 seconds = 9000 seconds
    };

    // --- UTILITIES ---

    /**
     * Selects a specified number of questions randomly from the master data.
     * @returns {Array} An array containing the selected question objects.
     */
    function getPracticeQuestions() {
      // Simple Fisher-Yates shuffle implementation
      const shuffled = [...masterData];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      // Return the first N questions
      return shuffled.slice(0, NUMBER_OF_PRACTICE_QUESTIONS);
    }

    // --- MODAL UTILITIES (Replacing alert/confirm) ---
    const messageModal = document.getElementById("messageModal");
    const modalTitle = document.getElementById("modalTitle");
    const modalMessage = document.getElementById("modalMessage");
    const modalActions = document.getElementById("modalActions");

    function closeModal() {
      messageModal.classList.add("hidden");
      messageModal.classList.remove("flex");
    }

    function showAlert(title, message) {
      modalTitle.textContent = title;
      modalMessage.textContent = message;
      modalActions.innerHTML = `
                <button onclick="closeModal()"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-1.5 px-3 transition duration-200 text-sm">
                    OK
                </button>
            `;
      messageModal.classList.remove("hidden");
      messageModal.classList.add("flex");
    }

    function showConfirm(title, message, onConfirm, onCancel = closeModal) {
      modalTitle.textContent = title;
      modalMessage.textContent = message;

      modalActions.innerHTML = '';

      const noBtn = document.createElement('button');
      noBtn.textContent = 'Cancel';
      noBtn.onclick = onCancel;
      noBtn.className = 'bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1.5 px-3 transition duration-200 text-sm';
      modalActions.appendChild(noBtn);

      const yesBtn = document.createElement('button');
      yesBtn.textContent = 'Confirm';
      yesBtn.onclick = () => {
        closeModal();
        if (onConfirm) onConfirm();
      };
      yesBtn.className = 'bg-red-500 hover:bg-red-600 text-white font-medium py-1.5 px-3 transition duration-200 text-sm';
      modalActions.appendChild(yesBtn);

      messageModal.classList.remove("hidden");
      messageModal.classList.add("flex");
    }


    // --- ELEMENTS ---
    const home = document.getElementById("home");
    const learn = document.getElementById("learn");
    const qnum = document.getElementById("qnum");
    const qtext = document.getElementById("qtext");
    const options = document.getElementById("options");
    const actionBtn = document.getElementById("actionBtn");
    const btnMenu = document.getElementById("btnMenu");
    const resetBtn = document.getElementById("resetBtn");
    const timerDisplay = document.getElementById("timerDisplay");
    const reviewNavigation = document.getElementById("reviewNavigation");

    const explanationDiv = document.getElementById("explanation");
    const noteText = document.getElementById("noteText");
    const resultView = document.getElementById("resultView");
    const questionView = document.getElementById("questionView");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const mainActions = document.getElementById("mainActions");
    const btnReview = document.getElementById("btnReview");


    // --- TIMER LOGIC ---
    function formatTime(totalSeconds) {
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      const pad = (num) => String(num).padStart(2, '0');
      return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }

    function startTimer() {
      stopTimer(); // Clear any existing timer
      timerDisplay.classList.remove("hidden");

      // Initial display and color check
      timerDisplay.textContent = formatTime(appState.timeRemaining);
      timerDisplay.classList.toggle("text-red-600", appState.timeRemaining <= 300);

      appState.timerInterval = setInterval(() => {
        appState.timeRemaining--;
        timerDisplay.textContent = formatTime(appState.timeRemaining);
        localStorage.setItem(LS_KEY_PRACTICE_TIME, appState.timeRemaining); // Save time every second

        if (appState.timeRemaining === 300) { // 5 minutes remaining
          timerDisplay.classList.add("text-red-600");
          showAlert("Time Warning", "Only 5 minutes remaining for the exam!");
        }

        if (appState.timeRemaining <= 0) {
          stopTimer();
          endPracticeMode(true); // true means time ran out
        }
      }, 1000);
    }

    function stopTimer() {
      if (appState.timerInterval) {
        clearInterval(appState.timerInterval);
        appState.timerInterval = null;
      }
      timerDisplay.classList.add("hidden");
    }


    // --- MODE SWITCHING ---
    function switchScreen(showHome) {
      if (showHome) {
        learn.classList.remove("show-flex");
        home.classList.add("show-flex");
      } else {
        home.classList.remove("show-flex");
        learn.classList.add("show-flex");
      }
      resultView.classList.add("hidden");
      questionView.classList.remove("hidden");
      window.scrollTo(0, 0);
    }

    function setupLearnMode() {
      appState.mode = 'learn';
      data = masterData; 
      // Load current index from LocalStorage
      let indexLearning = localStorage.getItem(LS_KEY_LEARN_INDEX);
      appState.current = !indexLearning || indexLearning < 0 ? 0 : Number(localStorage.getItem(LS_KEY_LEARN_INDEX));
      stopTimer();
      appState.isReviewing = false;
      switchScreen(false);
      renderQuestion();
    }

    function setupPracticeMode(shouldContinue = false) {
      appState.mode = 'practice';
      appState.isReviewing = false;

      if (shouldContinue) {
        const storedAnswers = JSON.parse(localStorage.getItem(LS_KEY_PRACTICE_ANSWERS) || '[]');
        const storedTime = Number(localStorage.getItem(LS_KEY_PRACTICE_TIME) || 9000);

        const storedPracticeData = JSON.parse(localStorage.getItem('aws_practice_data') || '[]');
        if (storedPracticeData.length > 0) {
          data = storedPracticeData;
        } else {
          // Fallback if question data wasn't saved (shouldn't happen with current implementation)
          data = getPracticeQuestions();
        }

        appState.practiceAnswers = storedAnswers;
        // Determine the next question index to display (index into the 'data' array)
        const maxAnsweredIndex = storedAnswers.length > 0 ? Math.max(...storedAnswers.map(a => a.qIndex)) : -1;
        appState.current = Math.min(maxAnsweredIndex + 1, data.length - 1);

        appState.timeRemaining = storedTime;

      } else {
        // Start a fresh exam
        data = getPracticeQuestions(); // Get 3 random questions
        localStorage.setItem('aws_practice_data', JSON.stringify(data)); // Store the chosen questions

        appState.practiceAnswers = [];
        appState.current = 0;
        appState.timeRemaining = 9000;
      }

      switchScreen(false);
      startTimer();
      renderQuestion();
    }

    // --- LOCAL STORAGE FUNCTIONS ---
    function clearPracticeLocalStorage() {
      localStorage.removeItem(LS_KEY_PRACTICE_ANSWERS);
      localStorage.removeItem(LS_KEY_PRACTICE_TIME);
      localStorage.removeItem('aws_practice_data'); // Clear stored question set
    }

    function saveLearnProgress() {
      // Chỉ lưu tiến độ nếu không phải câu cuối cùng
      if (appState.current < data.length) {
        localStorage.setItem(LS_KEY_LEARN_INDEX, appState.current);
      }
    }

    function savePracticeProgress() {
      // Only save if the practiceAnswers array is not empty
      if (appState.practiceAnswers.length > 0) {
        localStorage.setItem(LS_KEY_PRACTICE_ANSWERS, JSON.stringify(appState.practiceAnswers));
        // Time is saved every second in startTimer(), but save here just in case
        localStorage.setItem(LS_KEY_PRACTICE_TIME, appState.timeRemaining);
        // The current set of 3 questions is saved in setupPracticeMode
      }
    }


    // --- RENDERING ---
    function renderQuestion(qIndex = appState.current) {
      const totalQuestions = data.length;

      // Boundary check: if user navigates past the last question in a fresh practice exam
      if (qIndex >= totalQuestions) {
        appState.current = totalQuestions - 1;
        qIndex = appState.current;
      }

      const q = data[qIndex];

      qnum.textContent = `QUESTION ${qIndex + 1} / ${totalQuestions}`;
      qtext.textContent = q.q;
      options.innerHTML = "";

      // Hide explanation and clear text
      explanationDiv.style.display = 'none';
      noteText.textContent = '';
      qtext.classList.remove("text-green-600", "text-red-600"); // Clear feedback coloring

      // Control visibility of actionBtn and reviewNavigation
      mainActions.style.display = appState.isReviewing ? 'none' : 'flex';
      reviewNavigation.classList.toggle('hidden', !appState.isReviewing);

      // Determine button text for actionBtn
      if (appState.mode === 'learn') {
        // **UPDATED LOGIC**: Khi câu hỏi mới được tải, nút luôn reset về CHECK (hoặc RESET nếu là câu cuối)
        actionBtn.textContent = (qIndex === data.length - 1) ? "RESET" : "CHECK";
      } else {
        actionBtn.textContent = qIndex === totalQuestions - 1 ? "FINISH" : "NEXT";
      }

      // Set action button color: always green for CHECK/NEXT/FINISH in learning/practice mode
      actionBtn.classList.remove("bg-aws-orange", "hover:bg-yellow-600", "bg-gray-500", "bg-red-500", "bg-indigo-600", "hover:bg-indigo-700");
      actionBtn.classList.add("bg-green-500", "hover:bg-green-600");

      // Find the stored answer for this question index
      const currentAnswer = appState.practiceAnswers.find(a => a.qIndex === qIndex);

      q.o.forEach((op, i) => {
        const id = `chk${i}`;
        const label = document.createElement("label");
        label.className = "option-label";

        // Check if the current option was previously selected
        const isChecked = currentAnswer ? currentAnswer.selections.includes(i) : false;

        label.innerHTML = `
                    <input type='checkbox' name='option' id='${id}' value='${i}' ${isChecked ? 'checked' : ''} />
                    <span>${String.fromCharCode(65 + i)}. ${op.c}</span>
                `;
        options.appendChild(label);

        // If reviewing, lock and show feedback
        if (appState.isReviewing) {
          label.querySelector('input').disabled = true;
          lockAndShowFeedback(label, i, q, isChecked);
        } else if (appState.mode === 'learn') {
          // Khi renderQuestion() được gọi (tức là tải câu hỏi mới), options phải được bật
          label.querySelector('input').disabled = false;
        }
      });

      // Review Navigation setup
      if (appState.isReviewing) {
        if (q.nt) {
          noteText.textContent = q.nt;
          explanationDiv.style.display = 'block';
        }
        renderReviewNavigation();
      }
    }

    function renderReviewNavigation() {
      reviewNavigation.innerHTML = '';
      const totalQuestions = data.length;

      // BACK button
      const backBtn = document.createElement('button');
      backBtn.textContent = 'PREVIOUS';
      backBtn.onclick = handleReviewBack;
      backBtn.disabled = appState.current === 0;
      backBtn.className = `py-2.5 px-4 text-sm font-semibold transition duration-200 ${appState.current === 0
        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
        : 'bg-blue-500 hover:bg-blue-600 text-white shadow-md'
        }`;
      reviewNavigation.appendChild(backBtn);

      // NEXT button
      const nextBtn = document.createElement('button');
      const isLastQuestion = appState.current === totalQuestions - 1;
      nextBtn.textContent = isLastQuestion ? 'END REVIEW' : 'NEXT';
      nextBtn.onclick = handleReviewNext;
      nextBtn.className = `py-2.5 px-4 text-sm font-semibold transition duration-200 shadow-md w-full sm:w-auto ${isLastQuestion
        ? 'bg-red-500 hover:bg-red-600 text-white'
        : 'bg-green-500 hover:bg-green-600 text-white'
        }`;
      reviewNavigation.appendChild(nextBtn);
    }

    function handleReviewBack() {
      if (appState.current > 0) {
        appState.current--;
        renderQuestion(appState.current);
        window.scrollTo(0, 0);
      }
    }

    function handleReviewNext() {
      if (appState.current < data.length - 1) {
        appState.current++;
        renderQuestion(appState.current);
        window.scrollTo(0, 0);
      } else {
        // End of review, return to home
        showConfirm("End Review", "Do you want to return to the Home Screen?", () => {
          appState.mode = 'learn'; // Reset state to learn mode
          appState.isReviewing = false;
          switchScreen(true);
        });
        window.scrollTo(0, 0);
      }
    }

    // Removed feedback icon logic
    function lockAndShowFeedback(label, i, q, isUserChecked) {
      const op = q.o[i];
      const isAnswerCorrect = op.a === "yes";

      label.classList.remove("option-label", "cursor-pointer");
      label.classList.add("option-label", "cursor-default");

      if (isAnswerCorrect) {
        label.classList.add("correct-answer");
      } else if (isUserChecked && !isAnswerCorrect) {
        label.classList.add("incorrect-selection");
      }
    }


    // --- CORE LOGIC ---

    function lockAndShowLearningMode() {
      const q = data[appState.current];
      let isCorrect = true;

      q.o.forEach((op, i) => {
        const el = document.getElementById(`chk${i}`);
        const isUserChecked = el.checked;
        const isAnswerCorrect = op.a === "yes";

        el.disabled = true;

        // Logic to determine if the overall question is correct
        if (isAnswerCorrect && !isUserChecked) isCorrect = false;
        if (!isAnswerCorrect && isUserChecked) isCorrect = false;

        lockAndShowFeedback(el.parentElement, i, q, isUserChecked);
      });

      if (isCorrect) {
        qtext.textContent = `CORRECT! ${q.q}`;
        qtext.classList.add("text-green-600");
      } else {
        qtext.textContent = `INCORRECT. ${q.q}`;
        qtext.classList.add("text-red-600");
      }

      if (q.nt) {
        noteText.textContent = q.nt;
        explanationDiv.style.display = 'block';
      }
    }

    function savePracticeAnswer() {
      const pickedIndices = [...document.querySelectorAll("#options input")]
        .map((el, index) => el.checked ? index : -1)
        .filter(index => index !== -1);

      const existingIndex = appState.practiceAnswers.findIndex(a => a.qIndex === appState.current);

      const newAnswer = {
        qIndex: appState.current, // Index relative to the 3-question array
        selections: pickedIndices
      };

      if (existingIndex > -1) {
        appState.practiceAnswers[existingIndex] = newAnswer;
      } else {
        appState.practiceAnswers.push(newAnswer);
      }

      // Save to LocalStorage immediately
      savePracticeProgress();
    }

    function endPracticeMode(isTimeout = false) {
      stopTimer();

      // Calculate score
      let correctCount = 0;
      const totalQuestions = data.length;

      appState.practiceAnswers.forEach(userAnswer => {
        // Ensure the answer index is within bounds of the current data set
        if (userAnswer.qIndex >= data.length) return;

        const q = data[userAnswer.qIndex];
        let isCorrect = true;

        // Get the number of correct options
        const correctOptions = q.o.filter(o => o.a === 'yes').length;

        // 1. Check if the number of selections matches the number of correct answers
        if (userAnswer.selections.length !== correctOptions) {
          isCorrect = false;
        } else {
          // 2. Check if the selected indices match the correct indices
          q.o.forEach((op, i) => {
            const isAnswerCorrect = op.a === "yes";
            const isUserSelected = userAnswer.selections.includes(i);

            // If an option is correct but not selected, OR is incorrect but selected
            if ((isAnswerCorrect && !isUserSelected) || (!isAnswerCorrect && isUserSelected)) {
              isCorrect = false;
            }
          });
        }


        if (isCorrect) {
          correctCount++;
        }
      });

      const scorePercentage = ((correctCount / totalQuestions) * 100).toFixed(0);

      scoreDisplay.innerHTML = `<span class="text-aws-blue">${correctCount} / ${totalQuestions}</span><br>
                                      <span class="text-2xl text-aws-orange font-normal">${scorePercentage}%</span>`;

      if (isTimeout) {
        showAlert("Time's Up!", "The 150 minutes have expired. Your exam has been automatically submitted.");
      } else {
        showAlert("Completed", "You have completed the practice exam. Click 'Review Answers' for detailed results.");
      }

      // Clear practice state from localStorage upon completion
      clearPracticeLocalStorage();

      // Show result view
      questionView.classList.add("hidden");
      resultView.classList.remove("hidden");
      window.scrollTo(0, 0);
    }

    // --- EVENT HANDLERS ---

    function handleLearnClick() {
      setupLearnMode();
    }

    function handlePracticeClick() {
      const storedAnswers = localStorage.getItem(LS_KEY_PRACTICE_ANSWERS);
      if (storedAnswers && JSON.parse(storedAnswers).length > 0) {
        // If there are stored answers, ask the user if they want to continue
        const answeredCount = JSON.parse(storedAnswers).length;
        const totalQuestions = NUMBER_OF_PRACTICE_QUESTIONS;
        const timeStr = formatTime(Number(localStorage.getItem(LS_KEY_PRACTICE_TIME) || 9000));

        showConfirm(
          "Continue Exam?",
          `You have answered ${answeredCount} out of ${totalQuestions} questions and have ${timeStr} remaining. 
          Do you want to continue or start a new exam? (Starting a new exam selects 130 new random questions)`,
          // On Continue
          () => setupPracticeMode(true),
          // On Cancel (Start New)
          () => {
            // Ask again to confirm starting new, as it will erase progress
            showConfirm("Start New Exam", "Starting a new exam will erase previous progress and select 130 new questions. Are you sure?",
              () => {
                clearPracticeLocalStorage();
                setupPracticeMode(false);
              });
          }
        );
      } else {
        // No stored answers, start new
        setupPracticeMode(false);
      }
    }

    function handleActionClick() {
      const mode = actionBtn.textContent;

      // Check if user needs to select an option, except for "NEXT", "FINISH", and "RESET"
      if (mode !== "NEXT" && mode !== "FINISH" && mode !== "RESET") {
        const picked = [...document.querySelectorAll("#options input")].filter(x => x.checked);
        if (picked.length === 0) {
          showAlert("Action Required", "Please select at least one option.");
          return;
        }
      }


      if (appState.mode === 'learn') {
        if (mode === "CHECK") {
          // 1. Lock options, show feedback
          lockAndShowLearningMode();

          // 2. Change button to NEXT/RESET
          actionBtn.textContent = appState.current === data.length - 1 ? "RESET" : "NEXT";

          actionBtn.classList.remove("bg-aws-orange", "hover:bg-yellow-600");
          actionBtn.classList.add("bg-green-500", "hover:bg-green-600");
        } else if (mode === "NEXT") {
          // 3. Move to next question, save progress
          appState.current++;
          saveLearnProgress(); // <--- LƯU TIẾN ĐỘ VÀO LOCALSTORAGE Ở ĐÂY
          renderQuestion(); // Load câu hỏi mới, nút sẽ được reset về CHECK trong renderQuestion

        } else if (mode === "RESET") {
          showConfirm("Confirm Reset", `This action will reset progress to Question 1 (out of ${data.length} total). Are you sure?`, () => {
            appState.current = 0;
            saveLearnProgress();
            renderQuestion();
          });
        }
      } else if (appState.mode === 'practice') {
        if (mode === "NEXT" || mode === "FINISH") {
          savePracticeAnswer(); // Save the answer for the current question

          if (appState.current === data.length - 1) {
            endPracticeMode();
          } else {
            appState.current++;
            renderQuestion();
          }
        }
      }
      window.scrollTo(0, 0);
    }

    function handleReviewClick() {
      appState.mode = 'review';
      appState.isReviewing = true;
      appState.current = 0;

      resultView.classList.add("hidden");
      questionView.classList.remove("hidden");

      // When reviewing, data is already set from the practice run
      renderQuestion(appState.current);
      window.scrollTo(0, 0);
    }

    function handleMenuClick() {
      showConfirm("Confirm Return to Home", "Your current progress will be saved. Do you want to return to the Home Screen?", () => {

        stopTimer();

        // Save progress based on current mode
        if (appState.mode === 'learn') {
          saveLearnProgress();
        } else if (appState.mode === 'practice') {
          // Save answer for current question before exiting practice
          savePracticeAnswer();
          savePracticeProgress();
        }

        appState.mode = 'learn'; // Default back to learn mode for continuity
        appState.isReviewing = false;

        // Reset UI elements
        qtext.classList.remove("text-green-600", "text-red-600");
        explanationDiv.style.display = 'none';
        noteText.textContent = '';

        switchScreen(true);
      });
    }


    // --- EVENT ATTACHMENTS ---
    btnLearn.onclick = handleLearnClick;
    btnPractice.onclick = handlePracticeClick;
    actionBtn.onclick = handleActionClick;
    btnReview.onclick = handleReviewClick;
    resetBtn.onclick = handleResetClick;
    btnMenu.onclick = handleMenuClick;


    // Initial setup
    window.onload = () => {
      const jsonFiles = [
        "1_50.json",
        "51_100.json",
        "101_150.json",
        "151_200.json",
        "201_250.json",
        "251_300.json",
        "301_350.json",
        "351_400.json",
        "401_450.json",
        "451_500.json",
        "501_550.json",
        "551_600.json",
        "601_650.json",
        "651_700.json",
        "701_711.json"
      ];

      const promises = [];
      jsonFiles.forEach(f => {
        promises.push(fetch(f).then(r => r.json()));
      });

      Promise.all(promises)
        .then(allDataArrays => {
          masterData = allDataArrays.flat();
          data = masterData;
          const learnIndex = localStorage.getItem(LS_KEY_LEARN_INDEX);
          const practiceAnswers = localStorage.getItem(LS_KEY_PRACTICE_ANSWERS);

          if (learnIndex !== null && Number(learnIndex) < data.length) {
            // If there's a specific learning index saved, start in learning mode
            setupLearnMode();
          } else if (practiceAnswers !== null && JSON.parse(practiceAnswers).length > 0) {
            // If there's an active practice exam, prompt the user (same logic as clicking the button)
            handlePracticeClick();
          } else {
            // Default to home screen
            home.classList.add("show-flex");
          }
        });
    };

    function handleResetClick() {
      if (appState.mode === 'learn') {
        showConfirm("Confirm Reset", `This action will reset progress to Question 1 (out of ${data.length} total). Are you sure?`, () => {
          appState.current = 0;
          saveLearnProgress();
          renderQuestion();
        });
      } else if (appState.mode === 'practice') {
        showConfirm("Confirm Reset", "This will end the current practice exam and start a new one. Your progress will be lost. Are you sure?", () => {
          clearPracticeLocalStorage();
          setupPracticeMode(false);
        });
      }
    }
  </script>
</body>

</html>