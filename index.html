<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AWS SAA Learning: Practice Q&A</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --aws-blue: #232f3e;
      --aws-orange: #ff9900;
    }

    /* Set default font and background */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6;
      color: #1f2937;
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0px;
      font-size: 0.875rem; }

    .screen {
      display: none;
    }

    .show-flex {
      display: flex;
      flex-direction: column;
    }

    /* Custom styles for option feedback */
    .option-label {
      display: flex;
      align-items: flex-start;
      margin: 2px 0;
      padding: 5px;
      cursor: pointer;
      transition: all 0.15s ease-in-out;
      border: 1px solid #e5e7eb;
      font-size: 0.875rem;
    }

    .option-label:hover:not(.correct-answer):not(.incorrect-selection) {
      background-color: #f9fafb;
    }

    .correct-answer {
      /* Keep green for correct answers */
      background-color: #ecfdf5;
      border-color: #34d399;
      font-weight: 600;
      color: #059669;
    }

    .incorrect-selection {
      /* Removed red coloring as requested */
      background-color: transparent;
      border-color: #d1d5db;
      /* Neutral border */
      color: #1f2937;
      /* Neutral text */
    }

    .option-label input[type="checkbox"] {
      margin-top: 2px;
      min-width: 0.8rem;
      min-height: 0.8rem;
    }

    .option-label span {
      margin-left: 10px;
    }

    /* Style for the Explanation box - Removed background/border color */
    #explanation {
      display: none;
      margin-top: 20px;
      padding: 2px;
      background-color: transparent;
      /* No background color */
      border-left: 5px solid #d1d5db;
      /* Neutral gray border */
      color: #1f2937;
      /* Dark text color */
      line-height: 1.5;
      font-size: 0.875rem;
    }

    #explanation h4 {
      font-weight: 700;
      margin-bottom: 6px;
      color: #1f2937;
      /* Dark text color */
    }
  </style>
</head>

<body>
  <!-- Main Content Wrapper -->
  <div class="wrap">
    <!-- Header -->
    <header class="flex justify-between items-center py-3 border-b border-gray-300 mb-5">
      <h1 class="text-xl font-extrabold text-aws-blue">
        AWS SAA Study Kit
      </h1>
      <div class="flex items-center space-x-3">
        <!-- Timer Display -->
        <div id="timerDisplay" class="text-lg font-bold text-red-600 hidden">
          00:00:00
        </div>
        <!-- Menu Button -->
        <button id="btnMenu"
          class="bg-green-500 hover:bg-green-600 text-white text-sm font-semibold py-1.5 px-3 shadow-md transition duration-200">
         HOME
        </button>
      </div>
    </header>

    <!-- Home Screen -->
    <div id="home" class="screen show-flex p-4 bg-white rounded-xl shadow-lg">
      <h2 class="text-lg font-semibold mb-3 text-gray-800">Welcome to the AWS SAA Practice</h2>
      <p class="mb-5 text-gray-600 text-sm">Select a mode to begin your journey to certification.</p>
      <div class="space-y-3">
        <button id="btnLearn"
          class="w-full bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2.5 px-3 transition duration-200 shadow-lg text-sm">
          Learning Mode (Step-by-Step with Explanation - 5 Questions)
        </button>
        <button id="btnPractice"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2.5 px-3 shadow-lg transition duration-200 text-sm">
          Practice Exam (3 Random Questions - 150 Minutes)
        </button>
      </div>
    </div>

    <!-- Learning/Practice Screen -->
    <div id="learn" class="screen">
      <!-- Practice Mode Result View -->
      <div id="resultView" class="hidden bg-white p-5 shadow-lg mb-5">
        <h2 class="text-xl font-bold mb-3 text-gray-800">Practice Exam Results</h2>
        <div id="scoreDisplay" class="text-3xl font-extrabold text-center py-6"></div>
        <button id="btnReview"
          class="mt-3 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2.5 px-3 shadow-md transition duration-200 text-sm">
          Review Answers
        </button>
      </div>

      <!-- Question View -->
      <div id="questionView">
        <div id="qnum" class="text-base font-medium text-gray-600 mb-3"></div>
        <div class="bg-white p-5 rounded-xl shadow-lg">
          <div id="qtext" class="question-box text-lg font-semibold mb-5 text-gray-800"></div>
          <div id="options" class="space-y-2">
            <!-- Options will be rendered here -->
          </div>

          <!-- Explanation Area -->
          <div id="explanation">
            <h4>Explanation:</h4>
            <p id="noteText"></p>
          </div>

          <!-- Navigation for Review Mode -->
          <div id="reviewNavigation" class="mt-5 flex justify-between space-x-3 hidden">
            <!-- Buttons will be injected here during review mode -->
          </div>

          <button id="actionBtn"
            class="mt-5 w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2.5 px-3 shadow-md transition duration-200 text-sm">
            CHECK
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom Message/Confirmation Modal -->
  <div id="messageModal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center p-4 z-50">
    <div class="bg-white p-5 shadow-2xl w-full max-w-sm">
      <h3 id="modalTitle" class="text-lg font-bold mb-3 text-gray-800"></h3>
      <p id="modalMessage" class="text-gray-600 mb-5 text-sm"></p>
      <div id="modalActions" class="flex justify-end space-x-2">
        <!-- Buttons go here -->
      </div>
    </div>
  </div>

  <script>
    // --- LOCAL STORAGE KEYS ---
    const LS_KEY_LEARN_INDEX = "aws_learn_current_index";
    const LS_KEY_PRACTICE_ANSWERS = "aws_practice_answers";
    const LS_KEY_PRACTICE_TIME = "aws_practice_time";

    // --- EMBEDDED QUESTION DATA (Master Data) ---
    const masterData = [
      {
        "id": 1701,
        "q": "A development team needs to host a website that will be accessed by other teams. The website contents consist of HTML, CSS, client-side JavaScript, and images. Which method is the MOST cost-effective for hosting the website?",
        "o": [
          {
            "c": "Containerize the website and host it in AWS Fargate.",
            "a": "no"
          },
          {
            "c": "Create an Amazon S3 bucket and host the website there.",
            "a": "yes"
          },
          {
            "c": "Deploy a web server on an Amazon EC2 instance to host the website.",
            "a": "no"
          },
          {
            "c": "Configure an Application Load Balancer with an AWS Lambda target that uses the Express.js framework.",
            "a": "no"
          }
        ],
        "nt": "Amazon S3 is designed specifically for hosting static websites (HTML, CSS, JS, images) and is a highly cost-effective solution. You only pay for storage and requests, with no charges for compute resources (unlike Fargate, EC2, or Lambda) which would be unnecessary for serving static content. It eliminates the operational overhead of managing servers, containers, or application runtimes."
      },
      {
        "id": 1702,
        "q": "A company has a production workload that runs on 1,000 Amazon EC2 Linux instances. The workload is powered by third-party software. The company needs to patch the third-party software on all EC2 instances as quickly as possible to remediate a critical security vulnerability. What should a solutions architect do to meet these requirements?",
        "o": [
          {
            "c": "Create an AWS Lambda function to apply the patch to all EC2 instances.",
            "a": "no"
          },
          {
            "c": "Configure AWS Systems Manager Patch Manager to apply the patch to all EC2 instances.",
            "a": "no"
          },
          {
            "c": "Schedule an AWS Systems Manager maintenance window to apply the patch to all EC2 instances.",
            "a": "no"
          },
          {
            "c": "Use AWS Systems Manager Run Command to run a custom command that applies the patch to all EC2 instances.",
            "a": "yes"
          }
        ],
        "nt": "AWS Systems Manager Run Command allows you to remotely and securely run commands or scripts on a large number of EC2 instances (like 1,000) simultaneously and at scale. It's the fastest way to execute a one-time task, such as applying a critical security patch, without the need for scheduling a maintenance window (which introduces delay) or the complexity of writing and managing a custom Lambda function for command execution."
      },
      {
        "id": 1703,
        "q": "A company uses Amazon RDS for PostgreSQL databases for its data tier. The company must implement password rotation for the databases. Which solution meets this requirement with the LEAST operational overhead?",
        "o": [
          {
            "c": "Store the password in AWS Secrets Manager. Enable automatic rotation on the secret.",
            "a": "yes"
          },
          {
            "c": "Store the password in AWS Systems Manager Parameter Store. Enable automatic rotation on the parameter.",
            "a": "no"
          },
          {
            "c": "Store the password in AWS Systems Manager Parameter Store. Write an AWS Lambda function that rotates the password.",
            "a": "no"
          },
          {
            "c": "Store the password in AWS Key Management Service (AWS KMS). Enable automatic rotation on the customer master key (CMK).",
            "a": "no"
          }
        ],
        "nt": "AWS Secrets Manager is specifically designed for managing and rotating secrets like database credentials. It natively supports automatic rotation for RDS databases using an integrated Lambda function, eliminating the need for custom code. When enabled, it automatically updates the password in the database and the secret value according to a schedule you define, providing the least operational overhead compared to manual processes or building a custom rotation solution."
      },
      {
        "id": 1704,
        "q": "A company runs its application on Oracle Database Enterprise Edition. The company needs to migrate the application and the database to AWS. The company can use the Bring Your Own License (BYOL) model while migrating to AWS. The application uses third-party database features that require privileged access. A solutions architect must design a solution for the database migration. Which solution will meet these requirements MOST cost-effectively?",
        "o": [
          {
            "c": "Migrate the database to Amazon RDS for Oracle by using native tools. Replace the third-party features with AWS Lambda.",
            "a": "no"
          },
          {
            "c": "Migrate the database to Amazon RDS Custom for Oracle by using native tools. Customize the new database settings to support the third-party features.",
            "a": "yes"
          },
          {
            "c": "Migrate the database to Amazon DynamoDB by using AWS Database Migration Service (AWS DMS). Customize the new database settings to support the third-party features.",
            "a": "no"
          },
          {
            "c": "Migrate the database to Amazon RDS for PostgreSQL by using AWS Database Migration Service (AWS DMS). Rewrite the application code to remove the dependency on third-party features.",
            "a": "no"
          }
        ],
        "nt": "Amazon RDS Custom for Oracle is designed for applications that require access to the underlying OS and database environment for customization, which is necessary for supporting third-party features requiring privileged access. It allows BYOL, making it cost-effective. Standard RDS for Oracle does not grant the necessary OS access, and migrating to a different database engine (like DynamoDB or PostgreSQL) would require significant, costly application rewrites to replace the third-party features."
      },
      {
        "id": 1705,
        "q": "A company has deployed a multi-account strategy on AWS by using AWS Control Tower. The company has provided individual AWS accounts to each of its developers. The company wants to implement controls to limit AWS resource costs that the developers incur. Which solution will meet these requirements with the LEAST operational overhead?",
        "o": [
          {
            "c": "Instruct each developer to tag all their resources with a tag that has a key of CostCenter and a value of the developer's name. Use the required-tags AWS Config managed rule to check for the tag. Create an AWS Lambda function to terminate resources that do not have the tag. Configure AWS Cost Explorer to send a daily report to each developer to monitor their spending.",
            "a": "no"
          },
          {
            "c": "Use AWS Budgets to establish budgets for each developer account. Set up budget alerts for actual and forecast values to notify developers when they exceed or expect to exceed their assigned budget. Use AWS Budgets actions to apply a DenyAll policy to the developer's IAM role to prevent additional resources from being launched when the assigned budget is reached.",
            "a": "yes"
          },
          {
            "c": "Use AWS Cost Explorer to monitor and report on costs for each developer account. Configure Cost Explorer to send a daily report to each developer to monitor their spending. Use AWS Cost Anomaly Detection to detect anomalous spending and provide alerts.",
            "a": "no"
          },
          {
            "c": "Use AWS Service Catalog to allow developers to launch resources within a limited cost range. Create AWS Lambda functions in each AWS account to stop running resources at the end of each work day. Configure the Lambda functions to resume the resources at the start of each work day.",
            "a": "no"
          }
        ],
        "nt": "AWS Budgets provides a centralized, automated, and proactive way to manage costs across multiple accounts. Budgets Actions can automatically trigger an IAM policy (like a 'DenyAll' policy) to be applied to users/roles when their budget threshold is exceeded, effectively preventing further resource creation and controlling costs. This is a low-overhead, preventative control that scales well within a multi-account structure managed by AWS Control Tower, unlike reactive monitoring with Cost Explorer or complex, custom automation with Lambda and tagging."
      },
      {
        "id": 1706,
        "q": "A solutions architect is designing an application that will allow business users to upload objects to Amazon S3. The solution needs to maximize object durability. Objects also must be readily available at any time and for any length of time. Users will access objects frequently within the first 30 days after the objects are uploaded, but users are much less likely to access objects that are older than 30 days. Which solution meets these requirements MOST cost-effectively?",
        "o": [
          {
            "c": "Store all the objects in S3 Standard with an S3 Lifecycle rule to transition the objects to S3 Glacier after 30 days.",
            "a": "no"
          },
          {
            "c": "Store all the objects in S3 Standard with an S3 Lifecycle rule to transition the objects to S3 Standard-Infrequent Access (S3 Standard-IA) after 30 days.",
            "a": "yes"
          },
          {
            "c": "Store all the objects in S3 Standard with an S3 Lifecycle rule to transition the objects to S3 One Zone-Infrequent Access (S3 One Zone-IA) after 30 days.",
            "a": "no"
          },
          {
            "c": "Store all the objects in S3 Intelligent-Tiering with an S3 Lifecycle rule to transition the objects to S3 Standard-Infrequent Access (S3 Standard-IA) after 30 days.",
            "a": "no"
          }
        ],
        "nt": "S3 Standard offers high durability (99.999999999%) and low-latency access, perfect for frequently accessed new objects. After 30 days, when access patterns become infrequent, transitioning to S3 Standard-IA provides the same high durability but at a lower storage cost, while still maintaining millisecond access times (unlike S3 Glacier, which has retrieval delays). This combination optimizes cost for the access pattern without compromising on durability or immediate availability. S3 One Zone-IA has lower durability as it stores data in only one AZ, and Intelligent-Tiering incurs a monitoring and automation cost which is unnecessary when the access pattern shift (30 days) is predictable."
      },
      {
        "id": 1707,
        "q": "A solutions architect is designing a three-tier web application. The architecture consists of an internet-facing Application Load Balancer (ALB) and a web tier that is hosted on Amazon EC2 instances in private subnets. The application tier with the business logic runs on EC2 instances in private subnets. The database tier consists of Microsoft SQL Server that runs on EC2 instances in private subnets. Security is a high priority for the company. Which combination of security group configurations should the solutions architect use? (Choose three.)",
        "o": [
          {
            "c": "Configure the security group for the web tier to allow inbound HTTPS traffic from the security group for the ALB.",
            "a": "yes"
          },
          {
            "c": "Configure the security group for the web tier to allow outbound HTTPS traffic to 0.0.0.0/0.",
            "a": "no"
          },
          {
            "c": "Configure the security group for the database tier to allow inbound Microsoft SQL Server traffic from the security group for the application tier.",
            "a": "yes"
          },
          {
            "c": "Configure the security group for the database tier to allow outbound HTTPS traffic and Microsoft SQL Server trac to the security group for the web tier.",
            "a": "no"
          },
          {
            "c": "Configure the security group for the application tier to allow inbound HTTPS traffic from the security group for the web tier.",
            "a": "yes"
          },
          {
            "c": "Configure the security group for the application tier to allow outbound HTTPS traffic and Microsoft SQL Server traffic to the security group for the web tier.",
            "a": "no"
          }
        ],
        "nt": "1.  **Web Tier SG allows inbound HTTPS from ALB SG:** This is a fundamental security best practice. It ensures only the ALB can communicate with the web servers on the required port (443/HTTPS), blocking direct internet access to the instances. 2.  **Database Tier SG allows inbound SQL Server traffic from Application Tier SG:** This follows the principle of least privilege by restricting database access solely to the application tier instances. Authorizing by security group (rather than IP range) is more secure and dynamic. 3.  **Application Tier SG allows inbound HTTPS from Web Tier SG:** This ensures that only the web tier can initiate communication with the application tier on the expected port (443/HTTPS), creating a secure chain of communication between tiers."
      },
      {
        "id": 1708,
        "q": "A company has released a new version of its production application. The company's workload uses Amazon EC2, AWS Lambda, AWS Fargate, and Amazon SageMaker. The company wants to cost optimize the workload now that usage is at a steady state. The company wants to cover the most services with the fewest savings plans. Which combination of savings plans will meet these requirements? (Choose two.)",
        "o": [
          {
            "c": "Purchase an EC2 Instance Savings Plan for Amazon EC2 and SageMaker.",
            "a": "no"
          },
          {
            "c": "Purchase a Compute Savings Plan for Amazon EC2, Lambda, and SageMaker.",
            "a": "no"
          },
          {
            "c": "Purchase a SageMaker Savings Plan.",
            "a": "yes"
          },
          {
            "c": "Purchase a Compute Savings Plan for Lambda, Fargate, and Amazon EC2.",
            "a": "yes"
          },
          {
            "c": "Purchase an EC2 Instance Savings Plan for Amazon EC2 and Fargate.",
            "a": "no"
          }
        ],
        "nt": "1.  **Compute Savings Plan for Lambda, Fargate, and Amazon EC2:** This plan offers the most flexibility, applying to usage across EC2, Fargate, and Lambda, regardless of instance family, size, AZ, region, or OS. It covers three of the four services listed with a single plan. 2.  **SageMaker Savings Plan:** SageMaker is not covered by Compute or EC2 Instance Savings Plans. To get savings on SageMaker, a dedicated SageMaker Savings Plan is required. Therefore, the combination of a Compute Savings Plan (for EC2, Fargate, Lambda) and a SageMaker Savings Plan covers all four services with just two plans, which is the goal of covering the most services with the fewest plans."
      },
      {
        "id": 1709,
        "q": "A company uses a Microsoft SQL Server database. The company's applications are connected to the database. The company wants to migrate to an Amazon Aurora PostgreSQL database with minimal changes to the application code. Which combination of steps will meet these requirements? (Choose two.)",
        "o": [
          {
            "c": "Use the AWS Schema Conversion Tool (AWS SCT) to rewrite the SQL queries in the applications.",
            "a": "no"
          },
          {
            "c": "Enable Babelfish on Aurora PostgreSQL to run the SQL queries from the applications.",
            "a": "yes"
          },
          {
            "c": "Migrate the database schema and data by using the AWS Schema Conversion Tool (AWS SCT) and AWS Database Migration Service (AWS DMS).",
            "a": "yes"
          },
          {
            "c": "Use Amazon RDS Proxy to connect the applications to Aurora PostgreSQL.",
            "a": "no"
          },
          {
            "c": "Use AWS Database Migration Service (AWS DMS) to rewrite the SQL queries in the applications.",
            "a": "no"
          }
        ],
        "nt": "1.  **Enable Babelfish on Aurora PostgreSQL:** Babelfish for Aurora PostgreSQL allows the database to understand commands from applications written for Microsoft SQL Server. This means the application's T-SQL code and communication protocols can often run unchanged against Aurora, dramatically reducing the need for application code changes. 2.  **Migrate the database schema and data using AWS SCT and AWS DMS:** AWS SCT automatically converts the source database schema and a majority of the custom code to a format compatible with the target database (PostgreSQL). AWS DMS then handles the continuous data replication from the source to the target with minimal downtime. This combination is the standard, effective method for heterogeneous database migration."
      },
      {
        "id": 1710,
        "q": "A company plans to rehost an application to Amazon EC2 instances that use Amazon Elastic Block Store (Amazon EBS) as the attached storage. A solutions architect must design a solution to ensure that all newly created Amazon EBS volumes are encrypted by default. The solution must also prevent the creation of unencrypted EBS volumes. Which solution will meet these requirements?",
        "o": [
          {
            "c": "Configure the EC2 account attributes to always encrypt new EBS volumes.",
            "a": "no"
          },
          {
            "c": "Use AWS Config. Configure the encrypted-volumes identifier. Apply the default AWS Key Management Service (AWS KMS) key.",
            "a": "yes"
          },
          {
            "c": "Configure AWS Systems Manager to create encrypted copies of the EBS volumes. Reconfigure the EC2 instances to use the encrypted volumes.",
            "a": "no"
          },
          {
            "c": "Create a customer managed key in AWS Key Management Service (AWS KMS). Configure AWS Migration Hub to use the key when the company migrates workloads.",
            "a": "no"
          }
        ],
        "nt": "AWS Config allows you to define rules that check if resources comply with your desired configuration. The 'encrypted-volumes' managed rule can be used to check that all EBS volumes are encrypted. To *prevent* the creation of non-compliant resources, you can set up a remediation action. When AWS Config detects an unencrypted EBS volume (non-compliant), it can automatically trigger an action (e.g., via AWS Lambda) to encrypt the volume or even delete it, thus enforcing the encryption policy. While account-level default encryption is a good baseline, it doesn't actively *prevent* the creation of unencrypted volumes if explicitly requested; AWS Config provides the enforcement mechanism."
      },
      {
        "id": 1711,
        "q": "An ecommerce company wants to collect user clickstream data from the company's website for real-time analysis. The website experiences fluctuating traffic patterns throughout the day. The company needs a scalable solution that can adapt to varying levels of traffic. Which solution will meet these requirements?",
        "o": [
          {
            "c": "Use a data stream in Amazon Kinesis Data Streams in on-demand mode to capture the clickstream data. Use AWS Lambda to process the data in real time.",
            "a": "yes"
          },
          {
            "c": "Use Amazon Kinesis Data Firehose to capture the clickstream data. Use AWS Glue to process the data in real time.",
            "a": "no"
          },
          {
            "c": "Use Amazon Kinesis Video Streams to capture the clickstream data. Use AWS Glue to process the data in real time.",
            "a": "no"
          },
          {
            "c": "Use Amazon Managed Service for Apache Flink (previously known as Amazon Kinesis Data Analytics) to capture the clickstream data. Use AWS Lambda to process the data in real time.",
            "a": "no"
          }
        ],
        "nt": "Amazon Kinesis Data Streams is designed for real-time ingestion and processing of streaming data at scale. Its on-demand capacity mode automatically scales the shards (the base throughput units) up and down in response to changing data flow rates, making it perfectly suited for workloads with fluctuating traffic patterns like a website's clickstream. Integrating it with AWS Lambda for processing provides a serverless, highly scalable architecture where Lambda can be triggered by the incoming data stream to perform real-time analysis."
      }
    ];

    let data = masterData; // Initialize with master data for learning mode access
    const NUMBER_OF_PRACTICE_QUESTIONS = 3;

    // --- GLOBAL STATE ---
    const appState = {
      mode: 'learn', // 'learn', 'practice', or 'review'
      current: 0, // Current question index being displayed (index into the 'data' array)
      practiceAnswers: [], // Stores { qIndex: 0, selections: [0, 2] }
      isReviewing: false,
      // Timer state
      timerInterval: null,
      timeRemaining: 9000, // 150 minutes * 60 seconds = 9000 seconds
    };

    // --- UTILITIES ---

    /**
     * Selects a specified number of questions randomly from the master data.
     * @returns {Array} An array containing the selected question objects.
     */
    function getPracticeQuestions() {
      // Simple Fisher-Yates shuffle implementation
      const shuffled = [...masterData];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      // Return the first N questions
      return shuffled.slice(0, NUMBER_OF_PRACTICE_QUESTIONS);
    }

    // --- MODAL UTILITIES (Replacing alert/confirm) ---
    const messageModal = document.getElementById("messageModal");
    const modalTitle = document.getElementById("modalTitle");
    const modalMessage = document.getElementById("modalMessage");
    const modalActions = document.getElementById("modalActions");

    function closeModal() {
      messageModal.classList.add("hidden");
      messageModal.classList.remove("flex");
    }

    function showAlert(title, message) {
      modalTitle.textContent = title;
      modalMessage.textContent = message;
      modalActions.innerHTML = `
                <button onclick="closeModal()"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-1.5 px-3 rounded-lg transition duration-200 text-sm">
                    OK
                </button>
            `;
      messageModal.classList.remove("hidden");
      messageModal.classList.add("flex");
    }

    function showConfirm(title, message, onConfirm, onCancel = closeModal) {
      modalTitle.textContent = title;
      modalMessage.textContent = message;

      modalActions.innerHTML = '';

      const noBtn = document.createElement('button');
      noBtn.textContent = 'Cancel';
      noBtn.onclick = onCancel;
      noBtn.className = 'bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1.5 px-3 transition duration-200 text-sm';
      modalActions.appendChild(noBtn);

      const yesBtn = document.createElement('button');
      yesBtn.textContent = 'Confirm';
      yesBtn.onclick = () => {
        closeModal();
        if (onConfirm) onConfirm();
      };
      yesBtn.className = 'bg-red-500 hover:bg-red-600 text-white font-medium py-1.5 px-3 transition duration-200 text-sm';
      modalActions.appendChild(yesBtn);

      messageModal.classList.remove("hidden");
      messageModal.classList.add("flex");
    }


    // --- ELEMENTS ---
    const home = document.getElementById("home");
    const learn = document.getElementById("learn");
    const qnum = document.getElementById("qnum");
    const qtext = document.getElementById("qtext");
    const options = document.getElementById("options");
    const actionBtn = document.getElementById("actionBtn");
    const btnMenu = document.getElementById("btnMenu");
    const timerDisplay = document.getElementById("timerDisplay");
    const reviewNavigation = document.getElementById("reviewNavigation");

    const explanationDiv = document.getElementById("explanation");
    const noteText = document.getElementById("noteText");
    const resultView = document.getElementById("resultView");
    const questionView = document.getElementById("questionView");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const btnReview = document.getElementById("btnReview");


    // --- TIMER LOGIC ---
    function formatTime(totalSeconds) {
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      const pad = (num) => String(num).padStart(2, '0');
      return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }

    function startTimer() {
      stopTimer(); // Clear any existing timer
      timerDisplay.classList.remove("hidden");

      // Initial display and color check
      timerDisplay.textContent = formatTime(appState.timeRemaining);
      timerDisplay.classList.toggle("text-red-600", appState.timeRemaining <= 300);

      appState.timerInterval = setInterval(() => {
        appState.timeRemaining--;
        timerDisplay.textContent = formatTime(appState.timeRemaining);
        localStorage.setItem(LS_KEY_PRACTICE_TIME, appState.timeRemaining); // Save time every second

        if (appState.timeRemaining === 300) { // 5 minutes remaining
          timerDisplay.classList.add("text-red-600");
          showAlert("Time Warning", "Only 5 minutes remaining for the exam!");
        }

        if (appState.timeRemaining <= 0) {
          stopTimer();
          endPracticeMode(true); // true means time ran out
        }
      }, 1000);
    }

    function stopTimer() {
      if (appState.timerInterval) {
        clearInterval(appState.timerInterval);
        appState.timerInterval = null;
      }
      timerDisplay.classList.add("hidden");
    }


    // --- MODE SWITCHING ---
    function switchScreen(showHome) {
      if (showHome) {
        learn.classList.remove("show-flex");
        home.classList.add("show-flex");
      } else {
        home.classList.remove("show-flex");
        learn.classList.add("show-flex");
      }
      resultView.classList.add("hidden");
      questionView.classList.remove("hidden");
      window.scrollTo(0, 0);
    }

    function setupLearnMode() {
      appState.mode = 'learn';
      data = masterData; // Set data to ALL questions
      // Load current index from LocalStorage
      appState.current = Number(localStorage.getItem(LS_KEY_LEARN_INDEX) || 0);
      stopTimer();
      appState.isReviewing = false;
      switchScreen(false);
      renderQuestion();
    }

    function setupPracticeMode(shouldContinue = false) {
      appState.mode = 'practice';
      appState.isReviewing = false;

      if (shouldContinue) {
        const storedAnswers = JSON.parse(localStorage.getItem(LS_KEY_PRACTICE_ANSWERS) || '[]');
        const storedTime = Number(localStorage.getItem(LS_KEY_PRACTICE_TIME) || 9000);

        const storedPracticeData = JSON.parse(localStorage.getItem('aws_practice_data') || '[]');
        if (storedPracticeData.length > 0) {
          data = storedPracticeData;
        } else {
          // Fallback if question data wasn't saved (shouldn't happen with current implementation)
          data = getPracticeQuestions();
        }

        appState.practiceAnswers = storedAnswers;
        // Determine the next question index to display (index into the 'data' array)
        const maxAnsweredIndex = storedAnswers.length > 0 ? Math.max(...storedAnswers.map(a => a.qIndex)) : -1;
        appState.current = Math.min(maxAnsweredIndex + 1, data.length - 1);

        appState.timeRemaining = storedTime;

      } else {
        // Start a fresh exam
        data = getPracticeQuestions(); // Get 3 random questions
        localStorage.setItem('aws_practice_data', JSON.stringify(data)); // Store the chosen questions

        appState.practiceAnswers = [];
        appState.current = 0;
        appState.timeRemaining = 9000;
      }

      switchScreen(false);
      startTimer();
      renderQuestion();
    }

    // --- LOCAL STORAGE FUNCTIONS ---
    function clearPracticeLocalStorage() {
      localStorage.removeItem(LS_KEY_PRACTICE_ANSWERS);
      localStorage.removeItem(LS_KEY_PRACTICE_TIME);
      localStorage.removeItem('aws_practice_data'); // Clear stored question set
    }

    function saveLearnProgress() {
      // Chỉ lưu tiến độ nếu không phải câu cuối cùng
      if (appState.current < data.length) {
        localStorage.setItem(LS_KEY_LEARN_INDEX, appState.current);
      }
    }

    function savePracticeProgress() {
      // Only save if the practiceAnswers array is not empty
      if (appState.practiceAnswers.length > 0) {
        localStorage.setItem(LS_KEY_PRACTICE_ANSWERS, JSON.stringify(appState.practiceAnswers));
        // Time is saved every second in startTimer(), but save here just in case
        localStorage.setItem(LS_KEY_PRACTICE_TIME, appState.timeRemaining);
        // The current set of 3 questions is saved in setupPracticeMode
      }
    }


    // --- RENDERING ---
    function renderQuestion(qIndex = appState.current) {
      const totalQuestions = data.length;

      // Boundary check: if user navigates past the last question in a fresh practice exam
      if (qIndex >= totalQuestions) {
        appState.current = totalQuestions - 1;
        qIndex = appState.current;
      }

      const q = data[qIndex];

      qnum.textContent = `QUESTION ${qIndex + 1} / ${totalQuestions}`;
      qtext.textContent = q.q;
      options.innerHTML = "";

      // Hide explanation and clear text
      explanationDiv.style.display = 'none';
      noteText.textContent = '';
      qtext.classList.remove("text-green-600", "text-red-600"); // Clear feedback coloring

      // Control visibility of actionBtn and reviewNavigation
      actionBtn.style.display = appState.isReviewing ? 'none' : 'block';
      reviewNavigation.classList.toggle('hidden', !appState.isReviewing);

      // Determine button text for actionBtn
      if (appState.mode === 'learn') {
        // **UPDATED LOGIC**: Khi câu hỏi mới được tải, nút luôn reset về CHECK (hoặc RESET nếu là câu cuối)
        actionBtn.textContent = (qIndex === data.length - 1) ? "RESET" : "CHECK";
      } else {
        actionBtn.textContent = qIndex === totalQuestions - 1 ? "FINISH" : "NEXT";
      }

      // Set action button color: always green for CHECK/NEXT/FINISH in learning/practice mode
      actionBtn.classList.remove("bg-aws-orange", "hover:bg-yellow-600", "bg-gray-500", "bg-red-500", "bg-indigo-600", "hover:bg-indigo-700");
      actionBtn.classList.add("bg-green-500", "hover:bg-green-600");

      // Find the stored answer for this question index
      const currentAnswer = appState.practiceAnswers.find(a => a.qIndex === qIndex);

      q.o.forEach((op, i) => {
        const id = `chk${i}`;
        const label = document.createElement("label");
        label.className = "option-label";

        // Check if the current option was previously selected
        const isChecked = currentAnswer ? currentAnswer.selections.includes(i) : false;

        label.innerHTML = `
                    <input type='checkbox' name='option' id='${id}' value='${i}' ${isChecked ? 'checked' : ''} />
                    <span>${String.fromCharCode(65 + i)}. ${op.c}</span>
                `;
        options.appendChild(label);

        // If reviewing, lock and show feedback
        if (appState.isReviewing) {
          label.querySelector('input').disabled = true;
          lockAndShowFeedback(label, i, q, isChecked);
        } else if (appState.mode === 'learn') {
          // Khi renderQuestion() được gọi (tức là tải câu hỏi mới), options phải được bật
          label.querySelector('input').disabled = false;
        }
      });

      // Review Navigation setup
      if (appState.isReviewing) {
        if (q.nt) {
          noteText.textContent = q.nt;
          explanationDiv.style.display = 'block';
        }
        renderReviewNavigation();
      }
    }

    function renderReviewNavigation() {
      reviewNavigation.innerHTML = '';
      const totalQuestions = data.length;

      // BACK button
      const backBtn = document.createElement('button');
      backBtn.textContent = 'PREVIOUS';
      backBtn.onclick = handleReviewBack;
      backBtn.disabled = appState.current === 0;
      backBtn.className = `py-2.5 px-4 rounded-xl text-sm font-semibold transition duration-200 ${appState.current === 0
        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
        : 'bg-blue-500 hover:bg-blue-600 text-white shadow-md'
        }`;
      reviewNavigation.appendChild(backBtn);

      // NEXT button
      const nextBtn = document.createElement('button');
      const isLastQuestion = appState.current === totalQuestions - 1;
      nextBtn.textContent = isLastQuestion ? 'END REVIEW' : 'NEXT';
      nextBtn.onclick = handleReviewNext;
      nextBtn.className = `py-2.5 px-4 rounded-xl text-sm font-semibold transition duration-200 shadow-md w-full sm:w-auto ${isLastQuestion
        ? 'bg-red-500 hover:bg-red-600 text-white'
        : 'bg-green-500 hover:bg-green-600 text-white'
        }`;
      reviewNavigation.appendChild(nextBtn);
    }

    function handleReviewBack() {
      if (appState.current > 0) {
        appState.current--;
        renderQuestion(appState.current);
        window.scrollTo(0, 0);
      }
    }

    function handleReviewNext() {
      if (appState.current < data.length - 1) {
        appState.current++;
        renderQuestion(appState.current);
        window.scrollTo(0, 0);
      } else {
        // End of review, return to home
        showConfirm("End Review", "Do you want to return to the Home Screen?", () => {
          appState.mode = 'learn'; // Reset state to learn mode
          appState.isReviewing = false;
          switchScreen(true);
        });
        window.scrollTo(0, 0);
      }
    }

    // Removed feedback icon logic
    function lockAndShowFeedback(label, i, q, isUserChecked) {
      const op = q.o[i];
      const isAnswerCorrect = op.a === "yes";

      label.classList.remove("option-label", "cursor-pointer");
      label.classList.add("option-label", "cursor-default");

      if (isAnswerCorrect) {
        label.classList.add("correct-answer");
      } else if (isUserChecked && !isAnswerCorrect) {
        label.classList.add("incorrect-selection");
      }
    }


    // --- CORE LOGIC ---

    function lockAndShowLearningMode() {
      const q = data[appState.current];
      let isCorrect = true;

      q.o.forEach((op, i) => {
        const el = document.getElementById(`chk${i}`);
        const isUserChecked = el.checked;
        const isAnswerCorrect = op.a === "yes";

        el.disabled = true;

        // Logic to determine if the overall question is correct
        if (isAnswerCorrect && !isUserChecked) isCorrect = false;
        if (!isAnswerCorrect && isUserChecked) isCorrect = false;

        lockAndShowFeedback(el.parentElement, i, q, isUserChecked);
      });

      if (isCorrect) {
        qtext.textContent = `CORRECT! ${q.q}`;
        qtext.classList.add("text-green-600");
      } else {
        qtext.textContent = `INCORRECT. ${q.q}`;
        qtext.classList.add("text-red-600");
      }

      if (q.nt) {
        noteText.textContent = q.nt;
        explanationDiv.style.display = 'block';
      }
    }

    function savePracticeAnswer() {
      const pickedIndices = [...document.querySelectorAll("#options input")]
        .map((el, index) => el.checked ? index : -1)
        .filter(index => index !== -1);

      const existingIndex = appState.practiceAnswers.findIndex(a => a.qIndex === appState.current);

      const newAnswer = {
        qIndex: appState.current, // Index relative to the 3-question array
        selections: pickedIndices
      };

      if (existingIndex > -1) {
        appState.practiceAnswers[existingIndex] = newAnswer;
      } else {
        appState.practiceAnswers.push(newAnswer);
      }

      // Save to LocalStorage immediately
      savePracticeProgress();
    }

    function endPracticeMode(isTimeout = false) {
      stopTimer();

      // Calculate score
      let correctCount = 0;
      const totalQuestions = data.length;

      appState.practiceAnswers.forEach(userAnswer => {
        // Ensure the answer index is within bounds of the current data set
        if (userAnswer.qIndex >= data.length) return;

        const q = data[userAnswer.qIndex];
        let isCorrect = true;

        // Get the number of correct options
        const correctOptions = q.o.filter(o => o.a === 'yes').length;

        // 1. Check if the number of selections matches the number of correct answers
        if (userAnswer.selections.length !== correctOptions) {
          isCorrect = false;
        } else {
          // 2. Check if the selected indices match the correct indices
          q.o.forEach((op, i) => {
            const isAnswerCorrect = op.a === "yes";
            const isUserSelected = userAnswer.selections.includes(i);

            // If an option is correct but not selected, OR is incorrect but selected
            if ((isAnswerCorrect && !isUserSelected) || (!isAnswerCorrect && isUserSelected)) {
              isCorrect = false;
            }
          });
        }


        if (isCorrect) {
          correctCount++;
        }
      });

      const scorePercentage = ((correctCount / totalQuestions) * 100).toFixed(0);

      scoreDisplay.innerHTML = `<span class="text-aws-blue">${correctCount} / ${totalQuestions}</span><br>
                                      <span class="text-2xl text-aws-orange font-normal">${scorePercentage}%</span>`;

      if (isTimeout) {
        showAlert("Time's Up!", "The 150 minutes have expired. Your exam has been automatically submitted.");
      } else {
        showAlert("Completed", "You have completed the practice exam. Click 'Review Answers' for detailed results.");
      }

      // Clear practice state from localStorage upon completion
      clearPracticeLocalStorage();

      // Show result view
      questionView.classList.add("hidden");
      resultView.classList.remove("hidden");
      window.scrollTo(0, 0);
    }

    // --- EVENT HANDLERS ---

    function handleLearnClick() {
      setupLearnMode();
    }

    function handlePracticeClick() {
      const storedAnswers = localStorage.getItem(LS_KEY_PRACTICE_ANSWERS);
      if (storedAnswers && JSON.parse(storedAnswers).length > 0) {
        // If there are stored answers, ask the user if they want to continue
        const answeredCount = JSON.parse(storedAnswers).length;
        const totalQuestions = NUMBER_OF_PRACTICE_QUESTIONS;
        const timeStr = formatTime(Number(localStorage.getItem(LS_KEY_PRACTICE_TIME) || 9000));

        showConfirm(
          "Continue Exam?",
          `You have answered ${answeredCount} out of ${totalQuestions} questions and have ${timeStr} remaining. Do you want to continue or start a new exam? (Starting a new exam selects 3 new random questions)`,
          // On Continue
          () => setupPracticeMode(true),
          // On Cancel (Start New)
          () => {
            // Ask again to confirm starting new, as it will erase progress
            showConfirm("Start New Exam", "Starting a new exam will erase previous progress and select 3 new questions. Are you sure?",
              () => {
                clearPracticeLocalStorage();
                setupPracticeMode(false);
              });
          }
        );
      } else {
        // No stored answers, start new
        setupPracticeMode(false);
      }
    }

    function handleActionClick() {
      const mode = actionBtn.textContent;

      // Check if user needs to select an option, except for "NEXT", "FINISH", and "RESET"
      if (mode !== "NEXT" && mode !== "FINISH" && mode !== "RESET") {
        const picked = [...document.querySelectorAll("#options input")].filter(x => x.checked);
        if (picked.length === 0) {
          showAlert("Action Required", "Please select at least one option.");
          return;
        }
      }


      if (appState.mode === 'learn') {
        if (mode === "CHECK") {
          // 1. Lock options, show feedback
          lockAndShowLearningMode();

          // 2. Change button to NEXT/RESET
          actionBtn.textContent = appState.current === data.length - 1 ? "RESET" : "NEXT";

          actionBtn.classList.remove("bg-aws-orange", "hover:bg-yellow-600");
          actionBtn.classList.add("bg-green-500", "hover:bg-green-600");
        } else if (mode === "NEXT") {
          // 3. Move to next question, save progress
          appState.current++;
          saveLearnProgress(); // <--- LƯU TIẾN ĐỘ VÀO LOCALSTORAGE Ở ĐÂY
          renderQuestion(); // Load câu hỏi mới, nút sẽ được reset về CHECK trong renderQuestion

        } else if (mode === "RESET") {
          showConfirm("Confirm Reset", `This action will reset progress to Question 1 (out of ${data.length} total). Are you sure?`, () => {
            appState.current = 0;
            saveLearnProgress();
            renderQuestion();
          });
        }
      } else if (appState.mode === 'practice') {
        if (mode === "NEXT" || mode === "FINISH") {
          savePracticeAnswer(); // Save the answer for the current question

          if (appState.current === data.length - 1) {
            endPracticeMode();
          } else {
            appState.current++;
            renderQuestion();
          }
        }
      }
      window.scrollTo(0, 0);
    }

    function handleReviewClick() {
      appState.mode = 'review';
      appState.isReviewing = true;
      appState.current = 0;

      resultView.classList.add("hidden");
      questionView.classList.remove("hidden");

      // When reviewing, data is already set from the practice run
      renderQuestion(appState.current);
      window.scrollTo(0, 0);
    }

    function handleMenuClick() {
      showConfirm("Confirm Return to Home", "Your current progress will be saved. Do you want to return to the Home Screen?", () => {

        stopTimer();

        // Save progress based on current mode
        if (appState.mode === 'learn') {
          saveLearnProgress();
        } else if (appState.mode === 'practice') {
          // Save answer for current question before exiting practice
          savePracticeAnswer();
          savePracticeProgress();
        }

        appState.mode = 'learn'; // Default back to learn mode for continuity
        appState.isReviewing = false;

        // Reset UI elements
        qtext.classList.remove("text-green-600", "text-red-600");
        explanationDiv.style.display = 'none';
        noteText.textContent = '';

        switchScreen(true);
      });
    }


    // --- EVENT ATTACHMENTS ---
    btnLearn.onclick = handleLearnClick;
    btnPractice.onclick = handlePracticeClick;
    actionBtn.onclick = handleActionClick;
    btnReview.onclick = handleReviewClick;
    btnMenu.onclick = handleMenuClick;


    // Initial setup
    window.onload = () => {
      const learnIndex = localStorage.getItem(LS_KEY_LEARN_INDEX);
      const practiceAnswers = localStorage.getItem(LS_KEY_PRACTICE_ANSWERS);

      if (learnIndex !== null && Number(learnIndex) < masterData.length) {
        // If there's a specific learning index saved, start in learning mode
        setupLearnMode();
      } else if (practiceAnswers !== null && JSON.parse(practiceAnswers).length > 0) {
        // If there's an active practice exam, prompt the user (same logic as clicking the button)
        handlePracticeClick();
      } else {
        // Default to home screen
        home.classList.add("show-flex");
      }
    };

  </script>
</body>

</html>
